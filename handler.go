package jrpc2

import (
	"context"
	"errors"
	"reflect"
	"strings"

	"bitbucket.org/creachadair/stringset"
	"github.com/herenow/jrpc2/code"
)

// An Assigner assigns a Handler to handle the specified method name, or nil if
// no method is available to handle the request.
type Assigner interface {
	// Assign returns the handler for the named method, or nil.
	Assign(method string) Handler

	// Names returns a slice of all known method names for the assigner.  The
	// resulting slice is ordered lexicographically and contains no duplicates.
	Names() []string
}

// A Handler handles a single request.
type Handler interface {
	// Handle invokes the method with the specified request. The response value
	// must be JSON-marshalable or nil. In case of error, the handler can
	// return a value of type *jrpc2.Error to control the response code sent
	// back to the caller; otherwise the server will wrap the resulting value.
	//
	// The context passed to the handler by a *jrpc2.Server includes two extra
	// values that the handler may extract.
	//
	// To obtain a server metrics value, write:
	//
	//    sm := jrpc2.ServerMetrics(ctx)
	//
	// To obtain the inbound request message, write:
	//
	//    req := jrpc2.InboundRequest(ctx)
	//
	// The inbound request is the same value passed to the Handle method -- the
	// latter is primarily useful in handlers generated by jrpc2.NewHandler,
	// which do not receive this value directly.
	Handle(context.Context, *Request) (interface{}, error)
}

// A methodFunc adapts a function having the correct signature to a Handler.
type methodFunc func(context.Context, *Request) (interface{}, error)

func (m methodFunc) Handle(ctx context.Context, req *Request) (interface{}, error) {
	return m(ctx, req)
}

// A MapAssigner is a trivial implementation of the Assigner interface that
// looks up literal method names in a map of static Handlers.
type MapAssigner map[string]Handler

// Assign implements part of the Assigner interface.
func (m MapAssigner) Assign(method string) Handler { return m[method] }

// Names implements part of the Assigner interface.
func (m MapAssigner) Names() []string { return stringset.FromKeys(m).Elements() }

// A ServiceMapper combines multiple assigners into one, permitting a server to
// export multiple services under different names.
//
// Example:
//    m := jrpc2.ServiceMapper{
//      "Foo": jrpc2.NewService(fooService),  // methods Foo.A, Foo.B, etc.
//      "Bar": jrpc2.NewService(barService),  // methods Bar.A, Bar.B, etc.
//    }
//
type ServiceMapper map[string]Assigner

// Assign splits the inbound method name as Service.Method, and passes the
// Method portion to the corresponding Service assigner. If method does not
// have the form Service.Method, or if Service is not set in m, the lookup
// fails and returns nil.
func (m ServiceMapper) Assign(method string) Handler {
	parts := strings.SplitN(method, ".", 2)
	if len(parts) == 1 {
		return nil
	} else if ass, ok := m[parts[0]]; ok {
		return ass.Assign(parts[1])
	}
	return nil
}

// Names reports the composed names of all the methods in the service, each
// having the form Service.Method.
func (m ServiceMapper) Names() []string {
	var all stringset.Set
	for svc, assigner := range m {
		for _, name := range assigner.Names() {
			all.Add(svc + "." + name)
		}
	}
	return all.Elements()
}

// NewHandler adapts a function to a jrpc2.Handler. The concrete value of fn
// must be a function with one of the following type signatures:
//
//    func(context.Context) (Y, error)
//    func(context.Context, X) error
//    func(context.Context, X) (Y, error)
//    func(context.Context, ...X) (Y, error)
//    func(context.Context, *jrpc2.Request) (Y, error)
//
// for JSON-marshalable types X and Y. NewHandler will panic if the type of its
// argument does not have one of these forms.  The resulting method will handle
// encoding and decoding of JSON and report appropriate errors.
//
// Functions adapted by in this way can obtain the *jrpc2.Request value using
// the jrpc2.InboundRequest helper on the context value supplied by the server.
func NewHandler(fn interface{}) Handler {
	m, err := newHandler(fn)
	if err != nil {
		panic(err)
	}
	return m
}

// NewService adapts the methods of a value to a map from method names to
// Handler implementations as constructed by NewHandler. It will panic if obj
// has no exported methods with a suitable signature.
func NewService(obj interface{}) MapAssigner {
	out := make(MapAssigner)
	val := reflect.ValueOf(obj)
	typ := val.Type()

	// This considers only exported methods, as desired.
	for i, n := 0, val.NumMethod(); i < n; i++ {
		mi := val.Method(i)
		if v, err := newHandler(mi.Interface()); err == nil {
			out[typ.Method(i).Name] = v
		}
	}
	if len(out) == 0 {
		panic("no matching exported methods")
	}
	return out
}

var (
	ctxType = reflect.TypeOf((*context.Context)(nil)).Elem() // type context.Context
	errType = reflect.TypeOf((*error)(nil)).Elem()           // type error
	reqType = reflect.TypeOf((*Request)(nil))                // type *Request
)

func newHandler(fn interface{}) (Handler, error) {
	if fn == nil {
		return nil, errors.New("nil method")
	}

	// Special case: If fn has the exact signature of the Handle method, don't do
	// any (additional) reflection at all.
	if f, ok := fn.(func(context.Context, *Request) (interface{}, error)); ok {
		return methodFunc(f), nil
	}

	// Check that fn is a function of one of the correct forms.
	typ, err := checkFunctionType(fn)
	if err != nil {
		return nil, err
	}

	// Construct a function to unpack the request values from the request
	// message, based on the signature of the user's callback.
	var newinput func(req *Request) ([]reflect.Value, error)

	if typ.NumIn() == 1 {
		// Case 1: The function does not want any request parameters.
		newinput = func(req *Request) ([]reflect.Value, error) { return nil, nil }

	} else if a := typ.In(1); a == reqType {
		// Case 2: The function wants the underlying *Request value.
		newinput = func(req *Request) ([]reflect.Value, error) {
			return []reflect.Value{reflect.ValueOf(req)}, nil
		}

	} else {
		// Check whether the function wants a pointer to its argument.  We need
		// to create one either way to support unmarshaling, but we need to
		// indirect it back off if the callee didn't want it.

		// Case 3b: The function wants a bare value, not a pointer.
		argType := typ.In(1)
		undo := reflect.Value.Elem

		if argType.Kind() == reflect.Ptr {
			// Case 3c: The function wants a pointer.
			undo = func(v reflect.Value) reflect.Value { return v }
			argType = argType.Elem()
		}

		newinput = func(req *Request) ([]reflect.Value, error) {
			in := reflect.New(argType).Interface()
			if err := req.UnmarshalParams(in); err != nil {
				return nil, Errorf(code.InvalidParams, "wrong argument type: %v", err)
			}
			arg := reflect.ValueOf(in)
			return []reflect.Value{undo(arg)}, nil
		}
	}

	// Construct a function to decode the result values.
	var decodeOut func([]reflect.Value) (interface{}, error)

	if typ.NumOut() == 1 {
		// A function that returns only error: Result is always nil.
		decodeOut = func(vals []reflect.Value) (interface{}, error) {
			oerr := vals[0].Interface()
			if oerr != nil {
				return nil, oerr.(error)
			}
			return nil, nil
		}
	} else {
		// A function that returns a value and an error.
		decodeOut = func(vals []reflect.Value) (interface{}, error) {
			out, oerr := vals[0].Interface(), vals[1].Interface()
			if oerr != nil {
				return nil, oerr.(error)
			}
			return out, nil
		}
	}

	f := reflect.ValueOf(fn)
	call := f.Call
	if typ.IsVariadic() {
		call = f.CallSlice
	}

	return methodFunc(func(ctx context.Context, req *Request) (interface{}, error) {
		rest, ierr := newinput(req)
		if ierr != nil {
			return nil, ierr
		}
		args := append([]reflect.Value{reflect.ValueOf(ctx)}, rest...)
		return decodeOut(call(args))
	}), nil
}

func checkFunctionType(fn interface{}) (reflect.Type, error) {
	typ := reflect.TypeOf(fn)
	if typ.Kind() != reflect.Func {
		return nil, errors.New("not a function")
	} else if np := typ.NumIn(); np == 0 || np > 2 {
		return nil, errors.New("wrong number of parameters")
	} else if no := typ.NumOut(); no < 1 || no > 2 {
		return nil, errors.New("wrong number of results")
	} else if typ.In(0) != ctxType {
		return nil, errors.New("first parameter is not context.Context")
	} else if no == 2 {
		if typ.Out(1) != errType {
			return nil, errors.New("second result is not of type error")
		}
	} else if np == 1 {
		return nil, errors.New("no parameters and no result")
	} else if typ.Out(0) != errType {
		return nil, errors.New("result is not of type error")
	}
	return typ, nil
}
